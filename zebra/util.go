package zebra

import (
	"fmt"
	"io"
	"strings"

	"github.com/glycerine/zebrapack/msgp"
)

func ZkindFromString(s string) Zkind {
	s = strings.ToLower(s)
	switch s {
	case "":
		return Invalid
	case "invalid":
		return Invalid
	case "bytes":
		return Bytes
	case "string":
		return String
	case "float32":
		return Float32
	case "float64":
		return Float64
	case "complex64":
		return Complex64
	case "complex128":
		return Complex128
	case "uint":
		return Uint
	case "uint8":
		return Uint8
	case "uint16":
		return Uint16
	case "uint32":
		return Uint32
	case "uint64":
		return Uint64
	case "byte":
		return Byte
	case "int":
		return Int
	case "int8":
		return Int8
	case "int16":
		return Int16
	case "int32":
		return Int32
	case "int64":
		return Int64
	case "bool":
		return Bool
	case "intf":
		return Intf
	case "time":
		return Time
	case "ext":
		return Ext
	case "ident":
		// IDENT typically means a named struct
		return IDENT
	case "baseelem":
		return BaseElemCat
	case "map":
		return MapCat
	case "struct":
		return StructCat
	case "slice":
		return SliceCat
	case "array":
		return ArrayCat
	case "pointer":
		return PointerCat
	}
	panic(fmt.Errorf("unrecognized arg '%s' to ZkindFromString()", s))
}

func (i Zkind) String() string {
	switch i {
	case Invalid:
		return ""
	case Bytes:
		return "bytes"
	case String:
		return "string"
	case Float32:
		return "float32"
	case Float64:
		return "float64"
	case Complex64:
		return "complex64"
	case Complex128:
		return "complex128"
	case Uint:
		return "uint"
	case Uint8:
		return "uint8"
	case Uint16:
		return "uint16"
	case Uint32:
		return "uint32"
	case Uint64:
		return "uint64"
	case Byte:
		return "byte"
	case Int:
		return "int"
	case Int8:
		return "int8"
	case Int16:
		return "int16"
	case Int32:
		return "int32"
	case Int64:
		return "int64"
	case Bool:
		return "bool"

		// compound/non-primitives are uppercased
		// for readability
	case Intf:
		return "Intf"
	case Time:
		return "Time"
	case Ext:
		return "Ext"
	case IDENT:
		// IDENT typically means a named struct
		return "IDENT"
	case BaseElemCat:
		return "BaseElem"
	case MapCat:
		return "Map"
	case StructCat:
		return "Struct"
	case SliceCat:
		return "Slice"
	case ArrayCat:
		return "Array"
	case PointerCat:
		return "Pointer"
	default:
		panic(fmt.Errorf("unrecognized Zkind value %#v", i))
	}
}

// WriteToGo writes the zebrapack schema to w as a Go source file.
func (s *Schema) WriteToGo(w io.Writer, path string, pkg string) (err error) {
	if pkg == "" {
		fmt.Fprintf(w, "\npackage %s\n\n", s.SourcePackage)
	} else {
		fmt.Fprintf(w, "\npackage %s\n\n", pkg)
	}
	fmt.Fprintf(w, "// File re-generated by: 'zebrapack -write-to-go %s'.\n", path)
	fmt.Fprintf(w, "// The '%s' schema was originally created from: '%s'.\n\n", path, s.SourcePath)

	if len(s.Imports) > 0 {
		fmt.Fprintf(w, "import (\n")
	}
	for i := range s.Imports {
		fmt.Fprintf(w, "  %s\n", s.Imports[i])
	}
	if len(s.Imports) > 0 {
		fmt.Fprintf(w, ")\n\n")
	}

	fmt.Fprintf(w, "const zebraSchemaId64 = 0x%x\n\n", s.ZebraSchemaId)

	for i := range s.Structs {
		err = s.Structs[i].WriteToGo(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *Struct) WriteToGo(w io.Writer) (err error) {
	fmt.Fprintf(w, "\ntype %s struct {\n", s.StructName)
	for _, f := range s.Fields {
		needMsg := false
		zid := fmt.Sprintf("`zid:\"%v\"", f.Zid)
		msg := "msg:\""
		if f.FieldTagName != f.FieldGoName {
			msg += f.FieldTagName
			needMsg = true
		}
		if f.OmitEmpty {
			msg += ",omitempty"
			needMsg = true
		}
		if needMsg {
			zid += " " + msg + "\""
		}
		if f.Deprecated {
			zid += ` deprecated:"true"`
		}
		fmt.Fprintf(w, "    %s %s %s`\n", f.FieldGoName, f.FieldTypeStr, zid)
	}
	fmt.Fprintf(w, "}\n\n")
	return nil
}

// ErrNoStructNameFound is returned by ZebraToMsgp2 when it cannot locate the
// embedded struct name string.
var ErrNoStructNameFound = fmt.Errorf("error: no -1:struct-name field:value found in zebrapack struct")

func (sch *Schema) ZebraToMsgp2(bts []byte, ignoreMissingStructName bool) (out []byte, left []byte, err error) {

	// get the -1 key out of the map.
	var n uint32
	var nbs msgp.NilBitsStack
	n, bts, err = nbs.ReadMapHeaderBytes(bts)
	origMapFields := bts
	if err != nil {
		panic(err)
		return nil, nil, err
	}

	var fnum int
	var name string
	foundMinusOne := false

findMinusOneLoop:
	for i := uint32(0); i < n; i++ {
		fnum, bts, err = nbs.ReadIntBytes(bts)
		if fnum == -1 {
			name, bts, err = nbs.ReadStringBytes(bts)
			//fmt.Printf("\n found name = '%#v'\n", name)
			if err != nil {
				panic(err)
			}
			foundMinusOne = true
			break findMinusOneLoop
		}
		bts, err = msgp.Skip(bts)
		if err != nil {
			panic(err)
		}
	}

	if !foundMinusOne {
		if !ignoreMissingStructName {
			return nil, nil, ErrNoStructNameFound
		}
	}

	// INVAR: name is set. lookup the fields.
	tr, found := sch.Structs[name]
	if !found {
		foundMinusOne = false
	}

	// translate to msgpack2
	out = msgp.AppendMapHeader(out, n-1)

	// re-read
	bts = origMapFields
	for i := uint32(0); i < n; i++ {
		fnum, bts, err = nbs.ReadIntBytes(bts)
		if err != nil {
			panic(err)
		}
		if fnum == -1 {
			bts, err = msgp.Skip(bts)
			if err != nil {
				panic(err)
			}
			continue
		}
		if foundMinusOne {
			// encode fnum-> string translation for field name, then the field following
			out = msgp.AppendString(out, tr.Fields[fnum].FieldTagName)
		} else {
			// compensate with a fallback when no schema present:
			// just stringify the zid number so it shows up in the json.
			out = msgp.AppendString(out, fmt.Sprintf("%v", fnum))
		}

		// arrays and maps need to be recursively decoded.
		out, bts, err = sch.zebraToMsgp2helper(bts, out, ignoreMissingStructName)
		if err != nil {
			panic(err)
		}
	}
	return out, bts, nil
}

func (sch *Schema) zebraToMsgp2helper(bts []byte, startOut []byte,
	ignoreMissingStructName bool) (out []byte, left []byte, err error) {

	out = startOut
	var nbs msgp.NilBitsStack

	k := msgp.NextType(bts)
	switch k {
	case msgp.MapType:
		// recurse
		var o2 []byte
		o2, bts, err = sch.ZebraToMsgp2(bts, ignoreMissingStructName)
		out = append(out, o2...)
	case msgp.ArrayType:
		// recurse
		var sz uint32
		sz, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return nil, nil, err
		}
		out = msgp.AppendArrayHeader(out, sz)
		for i := uint32(0); i < sz; i++ {
			out, bts, err = sch.zebraToMsgp2helper(bts, out, ignoreMissingStructName)
			if err != nil {
				return nil, nil, err
			}
		}
	default:
		// find the end of the next field
		var end []byte
		end, err = msgp.Skip(bts)
		if err != nil {
			panic(err)
		}
		// copy field directly
		sz := len(bts) - len(end)
		out = append(out, bts[:sz]...)
		bts = end
	}

	return out, bts, nil
}
