package zebra

import (
	"fmt"
	"io"
	"strings"
)

func ZkindFromString(s string) Zkind {
	s = strings.ToLower(s)
	switch s {
	case "":
		return Invalid
	case "invalid":
		return Invalid
	case "bytes":
		return Bytes
	case "string":
		return String
	case "float32":
		return Float32
	case "float64":
		return Float64
	case "complex64":
		return Complex64
	case "complex128":
		return Complex128
	case "uint":
		return Uint
	case "uint8":
		return Uint8
	case "uint16":
		return Uint16
	case "uint32":
		return Uint32
	case "uint64":
		return Uint64
	case "byte":
		return Byte
	case "int":
		return Int
	case "int8":
		return Int8
	case "int16":
		return Int16
	case "int32":
		return Int32
	case "int64":
		return Int64
	case "bool":
		return Bool
	case "intf":
		return Intf
	case "time":
		return Time
	case "ext":
		return Ext
	case "ident":
		// IDENT typically means a named struct
		return IDENT
	case "baseelem":
		return BaseElemCat
	case "map":
		return MapCat
	case "struct":
		return StructCat
	case "slice":
		return SliceCat
	case "array":
		return ArrayCat
	case "pointer":
		return PointerCat
	}
	panic(fmt.Errorf("unrecognized arg '%s' to ZkindFromString()", s))
}

func (i Zkind) String() string {
	switch i {
	case Invalid:
		return ""
	case Bytes:
		return "bytes"
	case String:
		return "string"
	case Float32:
		return "float32"
	case Float64:
		return "float64"
	case Complex64:
		return "complex64"
	case Complex128:
		return "complex128"
	case Uint:
		return "uint"
	case Uint8:
		return "uint8"
	case Uint16:
		return "uint16"
	case Uint32:
		return "uint32"
	case Uint64:
		return "uint64"
	case Byte:
		return "byte"
	case Int:
		return "int"
	case Int8:
		return "int8"
	case Int16:
		return "int16"
	case Int32:
		return "int32"
	case Int64:
		return "int64"
	case Bool:
		return "bool"

		// compound/non-primitives are uppercased
		// for readability
	case Intf:
		return "Intf"
	case Time:
		return "Time"
	case Ext:
		return "Ext"
	case IDENT:
		// IDENT typically means a named struct
		return "IDENT"
	case BaseElemCat:
		return "BaseElem"
	case MapCat:
		return "Map"
	case StructCat:
		return "Struct"
	case SliceCat:
		return "Slice"
	case ArrayCat:
		return "Array"
	case PointerCat:
		return "Pointer"
	default:
		panic(fmt.Errorf("unrecognized Zkind value %#v", i))
	}
}

// WriteToGo writes the zebrapack schema to w as a Go source file.
func (s *Schema) WriteToGo(w io.Writer, path string) (err error) {
	fmt.Fprintf(w, "\npackage %s\n\n", s.SourcePackage)

	fmt.Fprintf(w, "// File re-generated by: 'zebrapack -write-to-go %s'.\n", path)
	fmt.Fprintf(w, "// The '%s' schema was originally created from: '%s'.\n\n", path, s.SourcePath)

	if len(s.Imports) > 0 {
		fmt.Fprintf(w, "import (\n")
	}
	for i := range s.Imports {
		fmt.Fprintf(w, "  %s\n", s.Imports[i])
	}
	if len(s.Imports) > 0 {
		fmt.Fprintf(w, ")\n\n")
	}

	fmt.Fprintf(w, "const zebraSchemaId64 = 0x%x\n\n", s.ZebraSchemaId)

	for i := range s.Structs {
		err = s.Structs[i].WriteToGo(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (s *Struct) WriteToGo(w io.Writer) (err error) {
	fmt.Fprintf(w, "\ntype %s struct {\n", s.StructName)
	for _, f := range s.Fields {
		needMsg := false
		zid := fmt.Sprintf("`zid:\"%v\"", f.Zid)
		msg := "msg:\""
		if f.FieldTagName != f.FieldGoName {
			msg += f.FieldTagName
			needMsg = true
		}
		if f.OmitEmpty {
			msg += ",omitempty"
			needMsg = true
		}
		if needMsg {
			zid += " " + msg + "\""
		}
		if f.Deprecated {
			zid += ` deprecated:"true"`
		}
		fmt.Fprintf(w, "    %s %s %s`\n", f.FieldGoName, f.FieldTypeStr, zid)
	}
	fmt.Fprintf(w, "}\n\n")
	return nil
}

/*
func (sch *Schema) EncodedStructInstanceToCompactBytes(b []byte) (out []byte, err error) {
	var str Struct
	left, err := str.DecodeMsg(b)
	if err != nil {
		return nil, err
	}
}
*/
